Separamos el problema en módulos y planteamos el diseño de cada uno por separado,
para luego armar la resolución final.

0) El tipo "pedido"
Creamos un struct "pedido_t" que contendrá 2 atributos: cantida de pizzas
y zona.
Especificación: indicamos tanto la cantidad de pizzas como la zona con un
dato de tipo int que irá del 1 al 5.
typedef struct pedido{
	int cant_pizzas;
	int zona;
} pedido_t;


1) Pedidos entrantes
Análisis: El programa debe llevar un registro de los pedidos recibidos, permitiendo 
agregar un nuevo pedido, modificar la cantidad de pizzas de un pedido 
y cancelar un pedido.
DISEÑO: 
Se tiene desde el arranque del programa, una única lista a la cual se 
agregan los nuevos pedidos, se modifican sus atributos y se cancelan. 
Proponemos implementar este conjunto de datos en una lista enlazada porque ni
la cola ni la pila permiten acceder a elementos que se encuentran en el 
medio (ni principio ni fin). Como el orden en el que se agregan los elementos
es de vital importancia, los métodos que usaremos para agregar y borrar
simularán los de una cola: los nuevos entran por el final y los viejos
salen por el principio.
Especificación: 
lista_t* pedidos_entrantes;

 
2) Preparación de pedidos: zonas 
Análisis: El programa debe contar con una opción para preparar todos los pedidos, 
agrupándolos según la zona de envío (los pedidos se preparan en 
el orden que fueron registrados). Una vez que los pedidos son preparados
no pueden ser modificados ni cancelados.
DISEÑO: 
Se tiene desde el arranque del programa, 5 colas (una por zona) en las que se 
van encolando los pedidos de acuerdo a su atributo "zona" y respetando 
su orden. Las características de los pedidos no se pueden modificar por 
enunciado y porque la estructura de cola no lo permite.
Por cada cola debe existir una estructura de datos semejante que funciona
como "auxiliar", para retener los pedidos que quedan en lista de espera por
no tener la cantida dde pizzas adecuada para la moto.
Especificación:
Definimos un struct zona_t, que contiene dos atributos: una cola llamada 
"cola_ppal" a donde van los pedidos_entrantes correspondientes, y una lista
enlazada "lista_de_espera" a donde van los pedidos postergados.
Elegimos una lista_enlazada para la lista de espera porque necesitaremos
iterar sobre los elementos para buscar un match, así como eliminarlos
si pasan a entrar en la moto.
Las zonas se agrupan en orden en un vector de tamaño 5 para facilitar
el acceso a cada una de ellas desde las funciones. Se nombran zona1, zona2,
zona3, zona4, zona5 y se referencian por su número (1, 2...).
typedef struct zona{
	cola_t* cola_ppal;
	lista_t* lista_espera;
	} zona_t;

3) Despacho de pedidos: la moto
Análisis: El programa debe permitir enviar los pedidos a los clientes. Esto consiste
en sacar algunos de los pedidos preparados por zona, utilizando una 
estrategia que permita optimizar los envíos. Los pedidos que no 
entren en la moto deberán postergarse para poder maximizar la cantidad
de pedidos a enviar en cada viaje. El programa debe informar los 
pedidos enviados.
DISEÑO: se cuenta con 1 moto capaz de llevar 5 pizzas a la vez. La moto
 será una pila "moto" en la cual se apilan las pizzas de los pedidos. 
 El máximo de pizzas por pedido es 5. La moto podrá llevar únicamente 
 pedidos enteros, es decir:
    - 1 pedido de 5 pizzas ó
    - 2 pedidos de 1 y 4 pizzas c/1 ó
                    2 y 3 pizzas c/1 ó
    - 3 pedidos de 1, 2 y 2 pizzas c/1 ó
                    3, 1 y 1 pizzas c/1 ó
    - 4 pedidos de 1, 1, 1 y 2 pizzas c/1 ó
    - 5 pedidos de 1, 1, 1, 1 y 1 pizzas c/1
    
Observación: para que la moto se llene siempre de 5 pizzas, los pedido
que queden "cortados" tienen que ser postergados. Es decir, el des-
encolamiento de los primeros pedidos en la cola deberá "saltearse"
al primero para intentar apilar el siguiente (o así sucesivamente hasta
encontrar un pedido que se ajuste a las cantidades de la moto). 
Dado que el método desencolar no permite saltearse nodos, debemos 
crear alguna estructura auxiliar que en la que se vayan guardando los 
pedidos salteados. Es decir, los pedidos de la cola siempre se van a des-
encolar, y algunos entrarán en la moto y otros irán a una especie de lista de
espera.

Pensamos en dos estrategias para resolver el asunto:
Estrategia 1: Se crea una cola auxiliar por zona. En la cola auxiliar se 
irán encolando los pedidos postergados por la cola de la zona respectiva. 
La cola auxiliar tendrá prioridad sobre la principal al momento de intentar 
cargar la moto.
Éste sería el método más "sencillo" y lógico en términos de implementación 
y funcionalidad. Es natural pensar que los que esperan se ubiquen en una cola. 
Sin embargo, la desventaja de este método es que, nuevamente, la cola no 
permite saltearse nodos y sólo puede desencolar por el principio. Por lo 
tanto, la función cargar_moto podrá chequear únicamente con el primer 
elemento de la cola auxiliar y si éste no entra en la moto, se pasará a 
chequear la cola principal. En perspectiva, esto generará en la cola_auxiliar
una tasa de crecimiento mucho mayor a la de decrecimiento (se encolarán 
varios pedidos por cada uno que se desencole), y los pedidos postergados
deberán esperar mucho para ser enviados.
Estrategia 2: Se crea una lista auxiliar por zona. La lista, en principio, 
simulará los métodos de una cola, es decir, agregará pedidos al último lugar 
(con lista_insertar_ultimo)  e intentará desagotar por el principio 
(lista_borrar_primero). Pero como sabemos que es muy probable que el primer 
pedido no cumpla las condiciones para pasar a la moto, y crear otra lista 
auxiliar para la lista auxiliar sería entrar en un loop interminable, la 
lista_aux podrá examinar cada pedido que contiene, en el orden de llegada 
(desde el primero hasta el \'faltimo), para compararlo con el valor de 
cant_pizzas que está buscando (o sea, cualquier valor adecuado para que 
entre en la moto). En cuanto lo encuentre, lo sacará de la lista con 
lista_borrar. De no encontrarlo pasará a revisar la cola principal de pedidos.
En términos de eficiencia, este procedimiento consume mucho más tiempo 
que el de la estrategia 1. Sin embargo, elegimos priorizar la necesidad 
de la pizzería de no demorar demasiado en la entrega de pedidos, en 
detrimento de la optimización del costo del programa. En consecuencia, 
implementaremos la estrategia 2.
Observación: Ambas estrategias parten de la base de que los pedidos ya 
apilados en la pila son "incuestionables". Por ejemplo: la moto está cargada 
con un pedido de 4 pizzas. Idealmente necesita un pedido de 1 pizza para 
completarse y salir. Suponiendo que la lista de espera tiene pedidos en 
el siguiente orden: 1) 3 pizzas 2) 2 pizzas 3) 5 pizzas, se mirará el 
primer pedido y se verá que no puede cargarse a la moto, ídem con el segundo 
y el tercero. En conclusión, la moto quedará con cuatro pizzas y se perderá 
en optimización. Si la moto pudiera, ante semejante situación, desapilar 
el pedido de 4 pizzas que tiene apilado y sumarlo a lista de espera, 
podría cargar los dos primeros pedidos de la lista de espera (3 y 2 pizzas) 
y salir en situación óptima.
La implementación de tal posibilidad disminuiría mucho la eficiencia del 
programa, puesto que el proceso de cargar y despachar una moto sería de 
un orden mayor en al menos un nivel a la opción básica.


4) Impresiones
El programa debe permitir observar el estado de la pizzería incluyendo 
los pedidos registrados hasta el momento, los pedidos preparados (por zona)
y los últimos N pedidos enviados (desde el más reciente al más antiguo).
DISEÑO: básicamente es una posibilidad de printear la lista de pedidos 
entrantes, las colas "zonai" y las últimas pila-moto que se se han creado. 
Especificación:
Para  imprimir las motos pasadas, éstas deben ir apilándose en una pila 
dentro de las funciones de la moto. Elegimos una pila porque al printearla 
se utilizará el método desapilar que devolverá los pedidos desde el más 
reciente hasta el más antiguo.


5) Menú
El programa deberá contar con una menú de opciones para la funcionalidad 
mencionada.
