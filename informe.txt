Separamos el problema en módulos y planteamos el diseño de cada uno por separado,
para luego armar la resolución final.

0) El tipo "pedido"
Creamos un struct "pedido_t" que contendrá 2 atributos: cantida de pizzas
y zona.
Especificación: indicamos tanto la cantidad de pizzas como la zona con un
dato de tipo int que irá del 1 al 5.
typedef struct pedido{
	int cant_pizzas;
	int zona;
} pedido_t;


1) Pedidos entrantes
Análisis: El programa debe llevar un registro de los pedidos recibidos, permitiendo 
agregar un nuevo pedido, modificar la cantidad de pizzas de un pedido 
y cancelar un pedido.
DISEÑO: 
Se tiene desde el arranque del programa, una única lista a la cual se 
agregan los nuevos pedidos, se modifican sus atributos y se cancelan. 
Proponemos implementar este conjunto de datos en una lista enlazada porque ni
la cola ni la pila permiten acceder a elementos que se encuentran en el 
medio (ni principio ni fin). Como el orden en el que se agregan los elementos
es de vital importancia, los métodos que usaremos para agregar y borrar
simularán los de una cola: los nuevos entran por el final y los viejos
salen por el principio.
Especificación: 
lista_t* pedidos_entrantes;

 
2) Preparación de pedidos 
Análisis: El programa debe contar con una opción para preparar todos los pedidos, 
agrupándolos según la zona de envío (los pedidos se preparan en 
el orden que fueron registrados). Una vez que los pedidos son preparados
no pueden ser modificados ni cancelados.
DISEÑO: 
Tenemos una lista "preparados" a la que se le agregan los pedidos entrantes
existentes con el método de "insertar_ultimo" para emular una cola.

3) Despacho de pedidos: la moto
Análisis: El programa debe permitir enviar los pedidos a los clientes. Esto consiste
en sacar algunos de los pedidos preparados por zona, utilizando una 
estrategia que permita optimizar los envíos. Los pedidos que no 
entren en la moto deberán postergarse para poder maximizar la cantidad
de pedidos a enviar en cada viaje. El programa debe informar los 
pedidos enviados.
DISEÑO: se cuenta con 1 moto capaz de llevar 5 pizzas a la vez. La moto
 será una lista_enlazada "moto" en la cual se insertan las pizzas de los pedidos. 
 El máximo de pizzas por pedido es 5. La moto podrá llevar únicamente 
 pedidos enteros, es decir:
    - 1 pedido de 5 pizzas ó
    - 2 pedidos de 1 y 4 pizzas c/1 ó
                    2 y 3 pizzas c/1 ó
    - 3 pedidos de 1, 2 y 2 pizzas c/1 ó
                    3, 1 y 1 pizzas c/1 ó
    - 4 pedidos de 1, 1, 1 y 2 pizzas c/1 ó
    - 5 pedidos de 1, 1, 1, 1 y 1 pizzas c/1
    
Observación: para que la moto se llene siempre de 5 pizzas, los pedido
que queden "cortados" tienen que ser postergados. Por esto elegimos que
la moto sea una lista y una cola: con un iterador, podremos ir evaluando
cada uno de los pedidos preparados (empezando por el primero en espera)
para cargar a la moto únicamente los adecuados. De esta forma podemos 
"saltear" pedidos de la lista que no son adecuados.
Implementación:	la función cargar_moto recibe la lista de pedidos preparados.
Si ésta no está vacía, procede a cargar el primer pedido en la moto. De acuerdo
a su zona, irá buscando entre el resto de la lista de preparados aquellos
que cumplan con la suma de pizzas máxima (en este caso 5) y los cargará
si es que los encuentra.
Una vez que la moto haya llegado a cargar su capacidad máxima o, de no llegar,
halla cargado todas los pedidos de la zona, se agrega a la lista de 
pedidos salientes y se destruye.

4) Impresiones
El programa debe permitir observar el estado de la pizzería incluyendo 
los pedidos registrados hasta el momento, los pedidos preparados (por zona)
y los últimos N pedidos enviados (desde el más reciente al más antiguo).
DISEÑO: básicamente es una posibilidad de printear la lista de pedidos 
entrantes, las colas "zonai" y los últimos pedidos que se han despachado. 
Especificación:
Para  imprimir las motos pasadas, éstas deben ir apilándose en una pila 
dentro de las funciones de la moto. Elegimos una pila porque al printearla 
se utilizará el método desapilar que devolverá los pedidos desde el más 
reciente hasta el más antiguo.


5) Menú
El programa deberá contar con una menú de opciones para la funcionalidad 
mencionada.
